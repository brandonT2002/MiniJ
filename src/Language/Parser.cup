/* 1. Package e importaciones */
package Language;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java_cup.runtime.*;
import Classes.Abstracts.*;
import Classes.Expressions.*;
import Classes.Instructions.*;
import Classes.Utils.Type;
import Components.Response;
import Components.ErrorS;

/* 2. Codigo para el parser, variables y metodos */

parser code 
{:
    ArrayList<Response> errorsS = new ArrayList<>();
    public ArrayList<Instruction> execute;
    public void syntax_error(Symbol sym) {
        errorsS.add(new Response(new ErrorS(sym.left,sym.right,sym.value,TOK.terminalNames[sym.sym])));
    }
    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception {
        errorsS.add(new Response("Error SintÃ¡ctico sin recuperar."));
    }
    public String getErrors() {
        return errorsS.stream().map(Object::toString).collect(Collectors.joining("\n-> "));
    }
    public boolean isSuccessExecution() {
        return !(errorsS.size() > 0);
    }
:} 

/* 3. Terminales*/
terminal String RW_main, RW_void, RW_String, RW_boolean, RW_char, RW_int, RW_double;
terminal String RW_if, RW_else, RW_for, RW_while, RW_do, RW_switch, RW_case, RW_default;
terminal String RW_break, RW_continue, RW_return;
terminal String RW_true, RW_false, RW_print;
terminal String TK_string, TK_char, TK_int, TK_double, TK_id, TK_inc, TK_dec, TK_add, TK_sub;
terminal String TK_plus, TK_minus, TK_mult, TK_div, TK_pow, TK_mod, TK_uminus;
terminal String TK_equequ, TK_notequ, TK_lessequ, TK_moreequ, TK_equ, TK_less, TK_more;
terminal String TK_and, TK_or, TK_not;
terminal String TK_lpar, TK_rpar, TK_lbrc, TK_rbrc, TK_comma, TK_colon, TK_semicolon;

/* 4. No Terminales*/
non terminal String INIT;
non terminal ArrayList<Instruction> INSTSGLOBAL;
non terminal ArrayList<Sentence> INSTRUCTIONS;
non terminal ArrayList<Expression> LISTARGS, LISTPARAMS;
non terminal Expression EXP, ARITHMETICS, RELATIONALS, LOGICS, INCDEC, CALLFUNC;
non terminal Instruction CALLMAINFUNC, INSTGLOBAL, PRINT, ADDSUB;
non terminal Instruction DECLID, INITIDS, INITID, DECLFUNC;
non terminal Sentence INSTRUCTION;
non terminal Sentence IFSTRUCT, SWITCHSTRUCT, ENVS, CASESDEFAULT, CASES, DEFAULT, CASE;
non terminal Sentence LOOPWHILE, LOOPDOWHILE, LOOPFOR, ARGSFOR, INITIALIZE, UPDATESFOR, UPDATEFOR, REASIGNS, REASIGN;
non terminal Type TYPE;
non terminal Block ENV;

/* 5. Precedencias */
precedence left TK_or;
precedence left TK_and;
precedence right TK_not;
precedence left TK_equequ, TK_notequ;
precedence left TK_lessequ, TK_moreequ, TK_less, TK_more;
precedence left TK_plus, TK_minus;
precedence left TK_mult, TK_div, TK_mod;
precedence nonassoc TK_pow;
precedence right TK_uminus;
precedence left TK_inc, TK_dec;

/* 6. Gramatica Libre de Contexto */

start with INIT;

INIT ::= INSTSGLOBAL :ins {:execute = ins;:};

INSTSGLOBAL ::=
    INSTSGLOBAL :l INSTGLOBAL :i {:RESULT = l; RESULT.add(i);                 :} |
    INSTGLOBAL :i                {:RESULT = new ArrayList<>(Arrays.asList(i));:} ;

INSTGLOBAL ::=
    CALLMAINFUNC :inst {:RESULT = inst;:} |
    DECLID       :inst {:RESULT = inst;:} |
    DECLFUNC     :inst {:RESULT = inst;:} |
    error        ;

CALLMAINFUNC ::=
    RW_main :m CALLFUNC :callMain TK_semicolon {:RESULT = new MainMethod(mleft, mright, callMain);:} ;

CALLFUNC ::=
    TK_id :id TK_lpar LISTARGS :l TK_rpar {:RESULT = new CallFunction(idleft, idright, id, l);                :} |
    TK_id :id TK_lpar TK_rpar             {:RESULT = new CallFunction(idleft, idright, id, new ArrayList<>());:} ;

LISTARGS ::=
    LISTARGS :l TK_comma EXP :e1 {:RESULT = l; RESULT.add(e1);                 :} |
    EXP :e1                      {:RESULT = new ArrayList<>(Arrays.asList(e1));:} ;

DECLID ::=
    TYPE INITIDS TK_semicolon ;

INITIDS ::=
    INITIDS TK_comma INITID |
    INITID                  ;

INITID ::=
    TK_id TK_equ EXP |
    TK_id            ;

DECLFUNC ::=
    TYPE    :t TK_id :id TK_lpar LISTPARAMS :l TK_rpar ENV :b {:RESULT = new Function(tleft, tright, id, l,                 b, t);        :} |
    RW_void :t TK_id :id TK_lpar LISTPARAMS :l TK_rpar ENV :b {:RESULT = new Function(tleft, tright, id, l,                 b, Type.NULL);:} |
    TYPE    :t TK_id :id TK_lpar TK_rpar ENV :b               {:RESULT = new Function(tleft, tright, id, new ArrayList<>(), b, t);        :} |
    RW_void :t TK_id :id TK_lpar TK_rpar ENV :b               {:RESULT = new Function(tleft, tright, id, new ArrayList<>(), b, Type.NULL);:} ;

LISTPARAMS ::=
    LISTPARAMS:l TK_comma TYPE :t TK_id :id {:RESULT = l; RESULT.add(new Parameter(tleft, tright, id, t));                 :} |
    TYPE :t TK_id :id                       {:RESULT = new ArrayList<>(Arrays.asList(new Parameter(tleft, tright, id, t)));:} ;

IFSTRUCT ::=
    RW_if TK_lpar EXP TK_rpar ENV RW_else IFSTRUCT |
    RW_if TK_lpar EXP TK_rpar ENV RW_else ENV      |
    RW_if TK_lpar EXP TK_rpar ENV                  ;

SWITCHSTRUCT ::=
    RW_switch TK_lpar EXP TK_rpar ENVS;

ENVS ::=
    TK_lbrc CASESDEFAULT TK_rbrc |
    TK_lbrc TK_rbrc              ;

CASESDEFAULT ::=
    CASES DEFAULT |
    CASES         |
    DEFAULT       ;

CASES ::= 
    CASES CASE |
    CASE       ;

CASE ::= 
    RW_case EXP TK_colon INSTRUCTIONS |
    RW_case EXP TK_colon ENV          |
    RW_case EXP TK_colon              ;

DEFAULT ::=
    RW_default TK_colon INSTRUCTIONS |
    RW_default TK_colon ENV          |
    RW_default TK_colon              ;

LOOPFOR ::=
    RW_for TK_lpar ARGSFOR TK_rpar ENV;

ARGSFOR ::=
    INITIALIZE TK_semicolon EXP TK_semicolon UPDATESFOR |
    INITIALIZE TK_semicolon EXP TK_semicolon            |
    INITIALIZE TK_semicolon TK_semicolon UPDATESFOR     |
    TK_semicolon EXP TK_semicolon UPDATESFOR            |
    INITIALIZE TK_semicolon TK_semicolon                |
    TK_semicolon EXP TK_semicolon                       |
    TK_semicolon TK_semicolon UPDATESFOR                |
    TK_semicolon TK_semicolon                           ;

INITIALIZE ::=
    TYPE REASIGNS |
    REASIGNS      ;

REASIGNS ::=
    REASIGNS TK_comma REASIGN |
    REASIGN                   ;

UPDATESFOR ::=
    UPDATESFOR TK_comma UPDATEFOR |
    UPDATEFOR                     ;

UPDATEFOR ::=
    INCDEC  |
    REASIGN |
    ADDSUB  ;

LOOPWHILE ::=
    RW_while TK_lpar EXP TK_rpar ENV ;

LOOPDOWHILE ::=
    RW_do ENV RW_while TK_lpar EXP TK_rpar TK_semicolon;

REASIGN ::=
    TK_id TK_equ EXP ;

ENV ::=
    TK_lbrc :l INSTRUCTIONS :ins TK_rbrc {:RESULT = new Block(lleft, lright, ins);              :} |
    TK_lbrc :l TK_rbrc                   {:RESULT = new Block(lleft, lright, new ArrayList<>());:} ;

INSTRUCTIONS ::=
    INSTRUCTIONS :l INSTRUCTION :i {:RESULT = l; RESULT.add(i);                 :} |
    INSTRUCTION :i                 {:RESULT = new ArrayList<>(Arrays.asList(i));:} ;

INSTRUCTION ::=
    DECLID       :ins                       {:RESULT = ins;:} |
    IFSTRUCT     :ins                       {:RESULT = ins;:} |
    SWITCHSTRUCT :ins                       {:RESULT = ins;:} |
    LOOPFOR      :ins                       {:RESULT = ins;:} |
    LOOPWHILE    :ins                       {:RESULT = ins;:} |
    LOOPDOWHILE  :ins                       {:RESULT = ins;:} |
    PRINT        :ins                       {:RESULT = ins;:} |
    ADDSUB       :ins TK_semicolon          {:RESULT = ins;:} |
    REASIGN      :ins TK_semicolon          {:RESULT = ins;:} |
    INCDEC       :ins TK_semicolon          {:RESULT = ins;:} |
    CALLFUNC     :ins TK_semicolon          {:RESULT = ins;:} |
    RW_return    :ins EXP :exp TK_semicolon {:RESULT = new Return(insleft, insright, exp); :} |
    RW_return    :ins TK_semicolon          {:RESULT = new Return(insleft, insright, null);:} |
    RW_continue  :ins TK_semicolon          {:RESULT = new Continue(insleft, insright);    :} |
    RW_break     :ins TK_semicolon          {:RESULT = new Break(insleft, insright);       :} |
    error                           ;

PRINT ::=
    RW_print :p TK_lpar EXP :exp TK_rpar TK_semicolon {:RESULT = new Print(pleft, pright, exp); :} |
    RW_print :p TK_lpar TK_rpar TK_semicolon          {:RESULT = new Print(pleft, pright, null);:} ;

TYPE ::=
    RW_String  {:RESULT = Type.STRING; :} |
    RW_int     {:RESULT = Type.INT;    :} |
    RW_boolean {:RESULT = Type.BOOLEAN;:} |
    RW_char    {:RESULT = Type.CHAR;   :} |
    RW_double  {:RESULT = Type.DOUBLE; :} ;

EXP ::=
    ARITHMETICS :exp         {:RESULT = exp;:} |
    RELATIONALS :exp         {:RESULT = exp;:} |
    LOGICS      :exp         {:RESULT = exp;:} |
    INCDEC      :exp         {:RESULT = exp;:} |
    CALLFUNC    :exp         {:RESULT = exp;:} |
    TK_id       :id          {:RESULT = new AccessID(idleft,idright,id);:} |
    TK_string   :p           {:RESULT = new Primitive(pleft, pright, p, Type.STRING); :} |
    TK_char     :p           {:RESULT = new Primitive(pleft, pright, p, Type.CHAR);   :} |
    TK_int      :p           {:RESULT = new Primitive(pleft, pright, p, Type.INT);    :} |
    TK_double   :p           {:RESULT = new Primitive(pleft, pright, p, Type.DOUBLE); :} |
    RW_true     :p           {:RESULT = new Primitive(pleft, pright, p, Type.BOOLEAN);:} |
    RW_false    :p           {:RESULT = new Primitive(pleft, pright, p, Type.BOOLEAN);:} |
    TK_lpar EXP :exp TK_rpar {:RESULT = exp;:} ;

INCDEC ::=
    TK_id :id TK_inc :s {:RESULT = new IncDec(idleft, idright, id, s);:} |
    TK_id :id TK_dec :s {:RESULT = new IncDec(idleft, idright, id, s);:} ;

ADDSUB ::=
    TK_id :id TK_add :s EXP :exp {:RESULT = new AddSub(idleft, idright, id, s, exp);:} |
    TK_id :id TK_sub :s EXP :exp {:RESULT = new AddSub(idleft, idright, id, s, exp);:} ;

ARITHMETICS ::=
    EXP :e1 TK_plus  :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_minus :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_mult  :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_div   :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_pow   :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_mod   :s EXP :e2 {:RESULT = new Arithmetic(e1left, e1right, e1, s, e2);:} |
    TK_minus :s         EXP :e2 {:RESULT = new Arithmetic(sleft, sright, null, s, e2);:} %prec TK_uminus;

RELATIONALS ::=
    EXP :e1 TK_equequ  :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_notequ  :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_lessequ :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_moreequ :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_less    :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_more    :s EXP :e2 {:RESULT = new Relational(e1left, e1right, e1, s, e2);:} ;

LOGICS ::=
    EXP :e1 TK_and :s EXP :e2 {:RESULT = new Logic(e1left, e1right, e1, s, e2);:} |
    EXP :e1 TK_or  :s EXP :e2 {:RESULT = new Logic(e1left, e1right, e1, s, e2);:} |
    TK_not :s         EXP :e2 {:RESULT = new Logic(sleft, sright, null, s, e2);:} ;